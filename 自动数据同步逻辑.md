# 数据同步逻辑

## 概述

当前的数据和云端同步主要通过 `src/extensions/pocketbase/hooks/useSync.ts` 实现。本文档整理完整的自动同步逻辑，确保数据在本地和云端之间保持一致，不会出现数据丢失的情况。

### 数据架构说明

- **数据源头**：Store（`src/stores/notes.ts`）是唯一的数据真实源
- **自动缓存**：修改 Store 中的 notes 会自动触发本地缓存更新（通过 Store 监听器实现）
- **同步目标**：Store ↔ 云端的双向同步
- **数据库角色**：作为缓存层，完全依赖 Store 的变化，无需手动操作

## Store 中心化架构

### 数据流原则

所有数据操作都通过 Store 进行：

1. **读取数据**：组件从 Store 读取 notes
2. **修改数据**：通过 Store 的 actions 修改 notes
3. **自动缓存**：Store 监听器自动将变更同步到本地缓存
4. **云端同步**：同步逻辑监听 Store 变化，决定是否上传到云端

### 单向数据流

```
UI 组件 → Store Actions → Store State 变更 → 触发监听器
                                            ↓
                                    自动缓存 + 云端同步
```

### 优势

- **简化逻辑**：无需手动管理数据库操作
- **数据一致性**：Store 是唯一真实源，避免数据不一致
- **响应式更新**：Vue 的响应式系统自动更新 UI
- **易于调试**：所有数据变更都可在 Store 中追踪
- **优化上传**：只上传本地产生的变更，避免重复上传云端推送来的数据

## 同步触发时机

### 1. 用户登录时

- **先建立 Realtime 连接，再执行数据同步**
- **目的**：确保在同步过程中不会错过任何实时推送
- **流程**：
  1. 验证用户身份
  2. 建立 Realtime 连接（开始接收实时推送）
  3. 拉取云端数据（基于最后同步时间）
  4. 合并到 Store，自动触发缓存更新
  5. 在同步过程中如果有新的变更，也能通过 Realtime 接收到

### 2. 网络重连时

- **WebSocket 中途断开后重新连接**：触发增量同步
- **目的**：同步断线期间的数据变更
- **流程**：
  1. 检测到 WebSocket 重新连接
  2. 对比本地和云端的最后更新时间
  3. 拉取增量数据
  4. 处理可能的冲突

### 3. 本地数据变更时

- **用户编辑/创建/删除备忘录后**：触发上传同步
- **目的**：将本地变更推送到云端
- **策略**：
  - **在线状态**：立即同步到云端
  - **离线状态**：标记为待同步，等待网络恢复后自动同步
  - **防抖处理**：编辑过程中延迟同步（如 2 秒无操作后再同步）

### 4. 定期轮询（可选）

- **定时检查**：每隔一定时间（如 5 分钟）检查是否有未同步数据
- **目的**：作为 WebSocket 的补充机制，确保数据最终一致性

## 数据流向

### 本地 → 云端（上传同步）

```
用户操作 → 更新 Store → 自动缓存 → 标记为待同步 → 上传到云端 → 更新同步状态
```

**处理逻辑**：

1. 用户编辑备忘录
2. 立即更新 Store 中的 notes 数据（更新 `updated = new Date()`）
3. Store 变更自动触发本地缓存更新
4. 设置全局标记 `needsSync = true`
5. 如果在线，触发同步：
   - 筛选 `note.updated > pocketbaseUpdated` 的备忘录
   - 批量上传这些备忘录到云端
6. 上传成功后：
   - 更新 `pocketbaseUpdated = notes中最新的 updated 值`
   - 设置 `needsSync = false`
7. 上传失败：保持 `needsSync = true`，等待重试

### 云端 → 本地（下载同步）

```
接收 WebSocket 推送 → 对比时间戳 → 更新 Store → 自动缓存 + UI 更新
```

**处理逻辑**：

1. WebSocket 收到服务端推送的数据变更事件
2. 对比本地备忘录的 `updated` 和云端推送的更新时间
3. 如果云端数据更新，更新 Store 中的对应备忘录：
   - **关键**：使用云端的 `updated`（不是当前时间）
   - 这样 `note.updated` 必然 <= `pocketbaseUpdated`
   - 下次同步时不会被误认为是本地变更
4. Store 更新自动触发：
   - 本地缓存同步更新
   - UI 响应式刷新
5. **全局 `pocketbaseUpdated` 保持不变**（只在上传成功时更新）

## 冲突处理策略

### 时间戳对比法

- **原则**：以最新的时间戳为准（Last Write Wins）
- **字段**：`updated`（云端）vs `pocketbaseUpdated`（本地）

### 冲突场景

1. **离线编辑后，云端也有更新**
   - 对比时间戳
   - 较新的覆盖较旧的
   - （未来可考虑）提示用户手动解决冲突

2. **并发编辑**
   - WebSocket 实时推送保证及时感知
   - 最后保存的版本生效

## 网络状态处理

### 在线状态

- 实时同步：编辑后立即上传
- 实时接收：通过 WebSocket 接收推送

### 离线状态

- 所有操作正常进行，更新 Store（自动触发缓存）
- 设置全局标记 `needsSync = true`
- 展示离线状态提示

### 从离线到在线

- 自动检测网络恢复
- 重新建立 WebSocket 连接
- 检查 `needsSync`，筛选 `updated > pocketbaseUpdated` 的备忘录并上传
- 拉取云端在离线期间的更新

## 数据完整性保证

### 乐观更新

1. 用户操作立即更新 Store（UI 自动响应）
2. 后台异步同步到云端
3. 同步失败时：
   - 保持 Store 中的变更
   - 标记为待同步，等待重试
   - 可选：向用户提示同步失败

### 失败重试机制

- 上传失败：保持 `needsSync = true`，`pocketbaseUpdated` 不更新
- 重试时：通过 `updated > pocketbaseUpdated` 自动找出所有待同步数据
- 时间戳机制确保不会漏掉任何本地变更
- 指数退避：首次立即重试，后续逐渐增加重试间隔
- 最大重试次数：避免无限重试

### 删除操作

- 软删除：本地标记 `deleted: true`
- 同步到云端后真正删除
- 确保删除操作不会丢失

## 待解决问题

### 1. 编辑时的同步时机

- ✅ **延迟同步**（推荐）：
  - 编辑时仅本地更新
  - 使用防抖（debounce），如 2 秒无操作后再同步
  - 优点：减少网络请求，提升用户体验
  - 缺点：需要处理更复杂的状态管理

**建议方案**：

- 采用防抖延迟同步
- 页面离开时强制同步未保存的数据
- 展示同步状态指示器（同步中/已同步）

### 2. 大量数据的同步策略

**问题**：首次登录或长时间离线后，如何高效同步大量数据？

**建议方案**：

- 分页拉取数据，避免一次性加载过多
- 优先同步最近修改的数据
- 后台增量同步历史数据

### 3. 冲突解决的用户体验

**问题**：发生冲突时，如何友好地提示用户？

**建议方案**：

- 默认采用时间戳策略自动解决
- 对于重要冲突，提供版本对比界面
- 允许用户手动选择保留哪个版本

## 技术实现要点

### 关键字段

**备忘录字段**：

- `updated`：备忘录的修改时间
- `deleted`：软删除标记

**全局状态**：

- `needsSync`：是否有数据需要上传
- `pocketbaseUpdated`：最后一次上传到云端的时间

**设计原理（时间戳自动区分方案）**：

通过时间戳对比自动区分本地变更和云端推送：

1. **本地修改时**：
   - 更新 `note.updated = new Date()`（当前时间）
   - 此时 `note.updated > pocketbaseUpdated`（因为是刚修改的）

2. **云端推送时**：
   - 保持 `note.updated` 为云端的时间（其他设备之前同步的时间）
   - 此时 `note.updated <= pocketbaseUpdated`（因为是之前已经同步过的）

3. **同步上传时**：
   - 筛选 `note.updated > pocketbaseUpdated` 的备忘录
   - 这些就是**本地产生的变更**，需要上传
   - 上传成功后，更新 `pocketbaseUpdated = new Date()`

**优势**：

- **极简设计**：只需维护一个全局时间戳
- **自动区分**：无需额外标记或集合，时间戳天然区分本地和云端数据
- **性能优秀**：时间戳对比是毫秒级操作
- **逻辑清晰**：易于理解和维护

### 关键模块

- `src/stores/notes.ts`：数据源头，状态管理核心
- `src/extensions/pocketbase/hooks/useSync.ts`：PocketBase 同步实现
- Store 监听器：自动触发缓存更新

### 性能优化

- 使用 WebSocket 减少轮询
- 批量处理数据变更
- 增量同步而非全量同步
- 合理使用缓存

## 总结

### 核心设计理念

**Store 是数据的唯一真实源（Single Source of Truth）**

1. **简化的数据流**：
   - 所有数据操作 → Store
   - Store 变更 → 自动触发缓存 + 云端同步

2. **无需手动数据库操作**：
   - 开发者只需关注 Store 的状态管理
   - 缓存和同步完全自动化
3. **清晰的职责分离**：
   - **Store**：数据管理和业务逻辑
   - **缓存层**：自动持久化
   - **同步层**：自动云端同步
4. **降低复杂度**：
   - 避免直接操作数据库带来的复杂性
   - 减少数据不一致的风险
   - 简化调试和维护
